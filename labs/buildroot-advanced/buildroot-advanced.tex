\subchapter
{Advanced aspects}
{Objectives:
  \begin{itemize}
  \item Use build time, dependency and filesystem size graphing capabilities
  \item Use licensing report generation, and add licensing
    information to your own packages
  \item Use \code{BR2_EXTERNAL}
  \end{itemize}
}

\section{Build time graphing}

When your embedded Linux system grows, its build time will also grow,
so it is often interesting to understand where the build time is
spent.

Since we just did a fresh clean rebuild at the end of the previous
lab, we can analyze the build time. The raw data has been generated by
Buildroot in \code{output/build/build-time.log}, which contains for
each step of each package the start time and end time (in seconds
since Epoch).

Now, let's get a better visualization of this raw data:

\begin{bashinput}
make graph-build
\end{bashinput}

Note: you may need to install \code{python-matplotlib} and \code{graphviz} on your machine.

The graphs are generated in \code{output/graphs}:

\begin{itemize}
\item \code{build.hist-build.pdf}, build time of each package, by
  build order
\item \code{build.hist-duration.pdf}, build time of each package, by
  build duration
\item \code{build.hist-name.pdf}, build time of each package, by
  package name
\item \code{build.pie-packages.pdf}, build time of each package, in
  proportion of the total build time
\item \code{build.pie-steps.pdf}, build time of each step
\end{itemize}

Explore those graphs, see which packages and steps are taking the
biggest amount of time.

Note that when you don't do a clean rebuild, the \code{build-time.log}
file gets appended and appended with all the successful builds, making
the resulting graphs unexploitable. So remember to always do a clean
full rebuild before looking at the build time graphs.

\section{Dependency graphing}

Another useful tool to analyze the build is graphing dependencies
between packages. The dependency graph is generated for your current
configuration: depending on the Buildroot configuration, a given
package may have different dependencies.

To generate the full dependency graph, do:

\begin{bashinput}
make graph-depends
\end{bashinput}

The graph is also generated in \code{output/graphs}, under the name
\code{graph-depends.pdf}. On the graph, identify the \code{bar} and
\code{ninvaders} packages you have created, and look at their
dependencies to see if they match your expectations.

Now, let's draw a graph for a much bigger system. To do this, create a
completely separate Buildroot output directory:

\begin{bashinput}
mkdir $HOME/__SESSION_NAME__-labs/buildroot-output-test-graph/
cd $HOME/__SESSION_NAME__-labs/buildroot-output-test-graph/
\end{bashinput}

We're going to create a Buildroot configuration, so create a file
named \code{.config} and put the following contents:

\begin{fileinput}
BR2_TOOLCHAIN_BUILDROOT_GLIBC=y
BR2_TOOLCHAIN_BUILDROOT_CXX=y
BR2_PACKAGE_MESA3D=y
BR2_PACKAGE_MESA3D_GALLIUM_DRIVER_SWRAST=y
BR2_PACKAGE_MESA3D_OPENGL_EGL=y
BR2_PACKAGE_MESA3D_OPENGL_ES=y
BR2_PACKAGE_XORG7=y
BR2_PACKAGE_XSERVER_XORG_SERVER=y
BR2_PACKAGE_LIBGTK3=y
BR2_PACKAGE_WEBKITGTK=y
\end{fileinput}

It represents a configuration that builds an internal toolchain, with
a X.org graphic server, the Mesa3D OpenGL implementation, the Gtk3
library, and the Webkit Web rendering engine. We're not going to build
this configuration, as it would take quite a bit of time, but we will
generate the dependency graph for it.

First, let's run \code{make menuconfig} to expand this minimal
configuration into a full configuration:

\begin{bashinput}
make -C $HOME/__SESSION_NAME__-labs/buildroot/ O=$(pwd) menuconfig
\end{bashinput}

Feel free to explore the configuration at this stage. Now, let's
generate the dependency graph:

\begin{bashinput}
make graph-depends
\end{bashinput}

Look at \code{graphs/graph-depends.pdf} and how complex it is. Now,
let's look at the dependencies of one specific package, let's say
\code{libgtk3}:

\begin{bashinput}
make libgtk3-graph-depends
\end{bashinput}

Now, open the graph generated at
\code{graphs/libgtk3-graph-depends.pdf}. As you can see, it is a lot
more readable.

Such dependencies graphs are very useful to understand why a package
is being built, and help identifying what you could do to reduce the
number of packages that are part of the build.

\section{Filesystem size graphing}

Run \code{make graph-size} and watch the PDF generated at
\code{output/graphs/graph-size.pdf}. You can also look at the CSV
files generated in \code{output/graphs/}.

\section{Licensing report}

Go back to our original build directory, in
\code{$HOME/__SESSION_NAME__-labs/buildroot/}.

As explained during the lectures, Buildroot has a built-in mechanism
to generate a licensing report, describing all the components part of
the generated embedded Linux system, and their corresponding licenses.

Let's generate this report for our system:

\begin{bashinput}
make legal-info
\end{bashinput}

In the output, you can see some interesting messages:

\begin{verbatim}
WARNING: bar: cannot save license (BAR_LICENSE_FILES not defined)
WARNING: libfoo: cannot save license (LIBFOO_LICENSE_FILES not defined)
WARNING: ninvaders: cannot save license (NINVADERS_LICENSE_FILES not defined)
\end{verbatim}

So, now update your \code{ninvaders}, \code{libfoo} and \code{bar}
packages to include license information. Run again \code{make
  legal-info}.

Now, explore \code{output/legal-info}, look at the \code{.csv} files,
the \code{.txt} files, and the various directories. Buildroot has
gathered for you most of what is needed to help with licensing
compliance.

\section{Use {\tt BR2\_EXTERNAL}}

We should have used \code{BR2_EXTERNAL} since the beginning of the
training, but we were busy learning about so many other things! So
it's finally time to use \code{BR2_EXTERNAL}.

The whole point of \code{BR2_EXTERNAL} is to allow storing your
project-specific packages, configuration files, root filesystem
overlay or patches outside of the Buildroot tree itself. It makes it
easier to separate the open-source packages from the proprietary ones,
and it makes updating Buildroot itself a lot simpler.

So, as recommended in the slides, the goal now is to use
\code{BR2_EXTERNAL} to move away from the main Buildroot tree the
following elements:

\begin{itemize}

\item The \code{bar} and \code{libfoo} packages. We will keep the
  \code{ninvaders} package in the Buildroot tree, since it's a
  publicly available open-source package, so it should be submitted to
  the official Buildroot rather than kept in a \code{BR2_EXTERNAL}
  tree.

\item The Linux kernel patch and Linux kernel configuration file.

\item The {\em rootfs overlay}

\item The {\em post-build script}

\item The {\em defconfig}

\end{itemize}

Your \code{BR2_EXTERNAL} tree should look like this:

\if\defstring{\labboard}{stm32mp1}
\begin{verbatim}
+-- board/
|   +-- bootlin/
|       +-- stm32mp1/
|           +-- linux.config
|           +-- post-build.sh
|           +-- patches/
|               +-- linux/
|                   +-- 0001-Add-nunchuk-driver.patch
|                   +-- 0002-ARM-dts-stm32mp157a-dk1-add-description-of-Nunchuk-o.patch
|           +-- rootfs-overlay/
|               +-- etc
|                   +-- network
|                       +-- interfaces
+-- package/
|   +-- bar
|       +-- 0001-Fix-missing-libconfig.h-include.patch
|       +-- bar.mk
|       +-- Config.in
|   +-- libfoo
|       +-- libfoo.mk
|       +-- Config.in
+-- configs
|   +-- bootlin_defconfig
+-- Config.in
+-- external.desc
+-- external.mk
\end{verbatim}
\else
\begin{verbatim}
+-- board/
|   +-- bootlin/
|       +-- beagleboneblack/
|           +-- linux.config
|           +-- post-build.sh
|           +-- patches/
|               +-- linux/
|                   +-- 0001-Add-nunchuk-driver.patch
|                   +-- 0002-Add-i2c1-and-nunchuk-nodes-in-dts.patch
|           +-- rootfs-overlay/
|               +-- etc
|                   +-- network
|                       +-- interfaces
|                   +-- init.d
|                       +-- S30usbgadget
+-- package/
|   +-- bar
|       +-- 0001-Fix-missing-libconfig.h-include.patch
|       +-- bar.mk
|       +-- Config.in
|   +-- libfoo
|       +-- libfoo.mk
|       +-- Config.in
+-- configs
|   +-- bootlin_defconfig
+-- Config.in
+-- external.desc
+-- external.mk
\end{verbatim}
\fi

Now, do a full rebuild using your \code{BR2_EXTERNAL} tree, and check
that your system builds and runs fine!

\section{Going further}

If you have some time left, let's improve our setup to use {\em
  genimage}. This way, we will be able to generate a complete SD card
image, which we can flash on a SD card, without having to manually
create partitions. Follow those steps:

\begin{itemize}

\item Change the Buildroot configuration to generate an {\em ext4}
  filesystem image

\item Take example on \code{board/stmicroelectronics/common/stm32mp157/genimage.cfg.template} to create
  your own \code{board/bootlin/stm32mp1/genimage.cfg}. Keep only
  the single Device Tree we need for our project.

\item Adjust the Buildroot configuration to use the
  \code{support/scripts/genimage.sh} script as a {\em post-image}
  script, and pass \code{-c board/bootlin/stm32mp1/genimage.cfg}
  as {\em post-image} script arguments. Make sure to enable
  \code{BR2_PACKAGE_HOST_GENIMAGE}.

\end{itemize}
