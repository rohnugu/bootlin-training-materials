\subchapter
{Application development with Buildroot}
{Objectives:
  \begin{itemize}
  \item Build and run your own application
  \item Remote debug your application
  \item Create a package for your application
  \end{itemize}
}

\section{Build and run your own application}

Let's create your own little application that we will use for
demonstration in this lab. Create a folder \code{$HOME/__SESSION_NAME__-labs/myapp},
and inside this folder a single C file called \code{myapp.c} with the
following contents:

\begin{fileinput}
#include <stdio.h>

int main(void) {
        printf("Hello World\n");
        return 0;
}
\end{fileinput}

To build this application, we'll use the cross-compiler generated by
Buildroot. To make this easy, let's add the Buildroot host directory
into our PATH:

\begin{bashinput}
export PATH=$HOME/__SESSION_NAME__-labs/buildroot/output/host/bin:$PATH
\end{bashinput}

Now you can build your application easily:

\begin{bashinput}
arm-linux-gcc -o myapp myapp.c
\end{bashinput}

Copy the myapp binary to your target using scp (we use the legacy {\em
SCP} protocol, as we haven't installed a {\em SFTP} server, hence
the \code{-O} option):

\begin{bashinput}
scp -O myapp root@192.168.42.2:
\end{bashinput}

And run the \code{myapp} application on your target.

Now, let's extend the application a little bit more to use a library,
the \code{libconfig} library we've already used in a previous
lab. Change the source code of the application to the one provided in
this lab data directory, \code{myapp.c}.

If you try to build this application with just:

\begin{bashinput}
arm-linux-gcc -o myapp myapp.c
\end{bashinput}

It fails to build because it does not link with \code{libconfig}. So
you can manually do:

\begin{bashinput}
arm-linux-gcc -o myapp myapp.c -lconfig
\end{bashinput}

Since \code{libconfig.so} is in \code{output/staging/usr/lib} and the
compiler is configured to automatically look in \code{output/staging}
as its {\em sysroot}, it works fine.

However, there's a better solution: using {\em pkg-config}. Buildroot
has installed a special version of \code{pkg-config} in
\code{output/host/bin}, which you can query for libraries
available for the target. Run:

\begin{bashinput}
pkg-config --list-all
\end{bashinput}

And check you have \code{libconfig} mentionned. You can query the
compiler and linker flags for \code{libconfig}:

\begin{bashinput}
pkg-config --cflags --libs libconfig
\end{bashinput}

And use that to build your application:

\begin{bashinput}
arm-linux-gcc -o myapp myapp.c $(pkg-config --cflags --libs libconfig)
\end{bashinput}

In the case of \code{libconfig}, it doesn't simplify a lot because the
compiler and linker flags are simple, but for some other libraries,
they are more complicated.

Copy the new version of \code{myapp} to your target, and run
it. Create a \code{myapp.cfg} config file, and run your application
again.

\section{Remote debug your application}

Our application is simple and works, but what if you need to debug it?
So let's set up remote debugging.

The {\em ARM} toolchain is provided with a pre-compiled {\em
  gdbserver}, so we'll simply use it. Enable the option
\code{BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY}, and then force the
re-installation of the toolchain using:

\begin{bashinput}
make toolchain-external-bootlin-reinstall
\end{bashinput}

Reflash your system, or alternatively, just copy
\code{output/target/usr/bin/gdbserver} to the target \code{/usr/bin/}
directory using \code{scp}.

To do some appropriate debugging, we need to have debugging symbols
available. So we need to do two things:

\begin{enumerate}

\item Rebuild our application with the \code{-g} flag.

\item Rebuild the Buildroot system with debugging symbols, so that
  shared libraries have debugging symbols. However, since we don't
  want to rebuild the entire Buildroot system now, we'll use a trick
  and rebuild only the library we need to have the debugging symbols
  for: \code{libconfig}. To achieve this, first go to Buildroot
  \code{menuconfig}, and in \code{Build options}, enable
  \code{build packages with debugging symbols}. Then, do \code{make
    libconfig-dirclean all} to force the rebuild of just
  \code{libconfig}.

\end{enumerate}

Now, on your target, start {\em gdbserver} in multi-process mode,
listening on TCP port 2345:

\begin{bashinput}
gdbserver --multi localhost:2345
\end{bashinput}

Back on the host, run the cross-gdb with the \code{myapp} application
as argument:

\begin{bashinput}
arm-linux-gdb myapp
\end{bashinput}

We need to tell \code{gdb} where the libraries can be found:

\begin{bashinput}
(gdb) set sysroot output/staging
\end{bashinput}

And then connect to the target:

\begin{bashinput}
(gdb) target extended-remote 192.168.42.2:2345
\end{bashinput}

Define which program we want to run on the target:

\begin{bashinput}
(gdb) set remote exec-file myapp
\end{bashinput}

Let's put a breakpoint on the \code{main} function, and start the
program:

\begin{bashinput}
(gdb) break main
(gdb) run
\end{bashinput}

It stops on the first line of the \code{main} function, which is the
call to \code{config_init}, implemented by the \code{libconfig}
library. If you do the {\em gdb} instruction \code{step}, {\em gdb}
will step into the function, so you can follow what happens. After
having done \code{step} once, you can do \code{backtrace} to see that
you are in the function \code{config_init} called by \code{main}:

\begin{verbatim}
(gdb) backtrace
#0  config_init (config=0xbefffc3c) at libconfig.c:725
#1  0x000106f0 in main () at myapp.c:11
\end{verbatim}

Note that if you want \code{gdbserver} to stop on the target, you need
to run the {\em gdb} command \code{monitor exit}.

\section{Create a package for your application}

Building manually your own application is not desirable, we obviously
want to create a Buildroot package for it. A useful mechanism to
package your own applications is to use the
\code{local} {\em site method}, which tells Buildroot that the source
code of your application is available locally.

Create a new package called \code{myapp} in your \code{BR2_EXTERNAL}
tree, and by using the \code{local} {\em site method}, make it use
directly the \code{myapp} source code from
\code{$HOME/__SESSION_NAME__-labs/myapp}. Remember that you can use \code{$(TOPDIR)}
to reference the top-level directory of the Buildroot sources.

For now, directly call \code{gcc} in the build commands. Of course, if
your application becomes more complicated, you should start using a
proper build system (Makefile, autotools, CMake, etc.).

When the package builds, you should see as the first step being done
that the \code{myapp} source code gets {\em rsynced} from
\code{$(HOME)/bootlin/myapp}:

\begin{verbatim}
>>> myapp custom Syncing from source dir /home/thomas/bootlin/myapp
\end{verbatim}

The build should now proceed to the end. Now, make a stupid but
visible change to the source code in \code{myapp.c}.

Restart the build of \code{myapp} using \code{make myapp-rebuild}, you
will see that Buildroot automatically {\em rsyncs} again the source
code. Then scp the file \code{output/target/usr/bin/myapp} to
\code{192.168.42.2:/usr/bin} and run \code{myapp} again on the target.

As you can see you can now develop your applications and libraries,
using your normal version control system and relying on Buildroot to
do all the configure, build and install steps for you.
